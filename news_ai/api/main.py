import json
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

import os
from dotenv import load_dotenv 

load_dotenv()
print("Loaded .env file from main.py")


from news_ai.core.config import PROCESSED_DATA_PATH
from news_ai.api.retrieval import query_article
from news_ai.api.generation import get_rag_answer
from dotenv import load_dotenv 
import os 

# --- Pydantic Model ---
# This defines the data structure the server EXPECTS for a POST request
class QueryRequest(BaseModel):
    article_id: str
    query_text: str

# --- Initialize FastAPI App ---
app = FastAPI(
    title="NewsAI API",
    description="API for the Inshorts-like news app with RAG Q&A.",
    version="1.0.0"
)

# --- API Endpoints ---

@app.get("/")
async def root():
    return {"message": "NewsAI API is running"}


@app.get("/feed")
async def get_feed():
    """
    Endpoint to get the processed news feed for the mobile app.
    Reads from the JSON file generated by the data pipeline.
    """
    try:
        with open(PROCESSED_DATA_PATH, 'r', encoding='utf-8') as f:
            feed_data = json.load(f)
        return {"feed": feed_data}
    except FileNotFoundError:
        raise HTTPException(
            status_code=404, 
            detail="Feed not found. Please run the data pipeline first."
        )
    except Exception as e:
        raise HTTPException(
            status_code=500, 
            detail=f"An internal server error occurred: {str(e)}"
        )


@app.post("/query")
async def ask_question(request: QueryRequest):
    """
    Endpoint to ask a question about a specific article using RAG.
    
    Expects a JSON body with:
    - "article_id": str
    - "query_text": str
    """
    print(f"Received query for article '{request.article_id}': '{request.query_text}'")
    
    try:
        # --- Step 1: Retrieval ---
        # Call the function from our retrieval.py module
        retrieval_results = query_article(
            article_id=request.article_id, 
            query_text=request.query_text
        )
        
        if retrieval_results.get("error"):
            raise HTTPException(
                status_code=404, 
                detail=retrieval_results.get("error")
            )
        
        context = retrieval_results.get("context")
        
        # --- Step 2: Generation ---
        # Call the function from our generation.py module
        final_answer = get_rag_answer(
            context=context, 
            query=request.query_text
        )
        
        if not final_answer:
            raise HTTPException(
                status_code=500, 
                detail="Failed to generate an answer from the LLM."
            )
            
        # --- Step 3: Respond ---
        return {
            "article_id": request.article_id,
            "query": request.query_text,
            "answer": final_answer.replace("\u202f", " ") 
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=500, 
            detail=f"An unexpected error occurred: {str(e)}"
        )
